import { BadRequestException, ConflictException, Injectable, InternalServerErrorException, NotFoundException } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { PasswordService } from 'src/auth/password.service';
import { MailService } from 'src/mail/mail.service';
import { HelperService } from 'src/helper/helper.service';
import { Prisma } from 'src/generated/postgres/prisma/client';
import { autogeneratedPasswordEnums, mailerEnums, superAdminEnums } from 'src/common/enums/shared.enum';
import type * as interfaces from 'src/common/interfaces/index.interfaces';
import * as dtos from "./dtos/index.dtos";

@Injectable()
export class EmployeesService {
  constructor(
    private prisma: PrismaService,
    private passwordService: PasswordService,
    private readonly helperService: HelperService,
    private readonly mailerService: MailService
  ) { }
  async createEmployee( body: dtos.CreateEmployeeDto) {
    try {
      const { email, user_name, phone_number } = body;
      const existingEmployee = await this.prisma.employees.findFirst({
        where: {
          OR: [
            { email },
            { user_name },
            { phone_number }
          ]
        }
      });

      if (existingEmployee) {
        throw new ConflictException('Email, User Name, or Phone Number already exists');
      }

      const password = this.helperService.generateRandomPass(autogeneratedPasswordEnums.LENGTH);

      const hashed = await this.passwordService.hashPassword(password);
      const employee = await this.prisma.employees.create({ data: { ...body, password: hashed } })
      if (!employee) {
        throw new ConflictException('Failed to create employee');
      }
      await this.mailerService.sendMail({
        to: [body.email],
        subject: mailerEnums.MAILER_SUBJECT,
        html: this.helperService.getPasswordTemplate(body.full_name, password),
      });
      const { password: _, ...result } = employee;

      return result;

    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === "P2003") {
          // Foreign key constraint failed
          throw new BadRequestException("Invalid foreign key reference");
        }
        // Unique constraint violation
      } else if (error instanceof Prisma.PrismaClientValidationError) {
        throw new BadRequestException("Invalid data provided");
      }
      // Fallback for unexpected errors
      throw new BadRequestException(`Failed to create employee: ${error.message}`);
    }
  }

  async getAllEmployees(language: string, user: interfaces.User, pagination: interfaces.Pagination, filter: string) {
    const employees = await this.prisma.employees.findMany({ 
      where: { full_name: { contains: filter, mode: 'insensitive' },
      ...(user.role_name !== superAdminEnums.ROLE_EN_NAME
        ? { roles_employees_role_idToroles: { is: { company_project_id: +user.company_project_id } } }
        : {})
     },
      skip: pagination.skip,
      take: pagination.limit,
      include: { roles_employees_role_idToroles: { select: { [`${language}_name`]: true, id: true, company_project_id: true, 
      company_project: { select: { company_code: true, project_code: true, [`${language}_name`]: true } } 
      } }, employees : {select: {id:true, full_name:true}} } 
    });

      const totalCount = await this.prisma.employees.count({
        where: { full_name: { contains: filter, mode: 'insensitive' },
        ...(user.role_name !== superAdminEnums.ROLE_EN_NAME 
          ? { roles_employees_role_idToroles: { is: { company_project_id: +user.company_project_id } } }
          : {})
       }
      });

    const formattedEmployees = employees.map((employee) => {
      const { password, roles_employees_role_idToroles: role, employees:manager,...emp } = employee;
      const roleName = role ? role[`${language}_name`] : null;
      const projectID = role ? role.company_project_id : null;
      const projectName = role?.company_project
        ? role.company_project[`${language}_name`]
        : null;

      return {
        ...emp,
        role_name: roleName,
        project_id: projectID,
        project_name: projectName,
        manager
      };
    });

    return {
      totalCount,
      totalPages: Math.ceil(totalCount / pagination.limit),
      employees: formattedEmployees,

    };
  }

  async updateEmployee( body: dtos.UpdateEmployeeDto, id: string) {
    try {
      const employee = await this.prisma.employees.findUnique({ where: { id } });
      if (!employee) {
        throw new NotFoundException('Employee not found');
      }
      const updatedEmployee = await this.prisma.employees.update({ where: { id }, data: body });      
      if (!updatedEmployee) {
        throw new ConflictException('Failed to update employee');
      }
      return { message: 'Employee updated successfully' };
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === "P2003") {
          // Foreign key constraint failed
          throw new BadRequestException("Invalid foreign key reference");
        }
        // Unique constraint violation
      } else if (error instanceof Prisma.PrismaClientValidationError) {
        throw new BadRequestException("Invalid data provided");
      }
      // Fallback for unexpected errors
      throw new InternalServerErrorException("Failed to update employee");
    }
  }
}
