import { BadRequestException, ConflictException, Injectable, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { CreateEmployeeDto } from './dtos/create-employee.dto';
import { PasswordService } from 'src/auth/password.service';
import { MailService } from 'src/mail/mail.service';
import { HelperService } from 'src/helper/helper.service';
import { Prisma } from 'src/generated/postgres/prisma/client';
import { autogeneratedPasswordEnums, mailerEnums, superAdminEnums } from 'src/common/enums/shared.enum';

@Injectable()
export class EmployeesService {
  constructor(
    private prisma: PrismaService,
    private passwordService: PasswordService,
    private readonly helperService: HelperService,
    private readonly mailerService: MailService
  ) { }
  async createEmployee(user, body: CreateEmployeeDto) {
    try {
      const { email, user_name, phone_number } = body;
      const existingEmployee = await this.prisma.employees.findFirst({
        where: {
          OR: [
            { email },
            { user_name },
            { phone_number }
          ]
        }
      });

      if (existingEmployee) {
        throw new ConflictException('Email, User Name, or Phone Number already exists');
      }

      const password = this.helperService.generateRandomPass(autogeneratedPasswordEnums.LENGTH);

      const hashed = await this.passwordService.hashPassword(password);
      const employee = await this.prisma.employees.create({ data: { ...body, password: hashed } })
      if (!employee) {
        throw new ConflictException('Failed to create employee');
      }
      await this.mailerService.sendMail({
        to: [body.email],
        subject: mailerEnums.MAILER_SUBJECT,
        html: this.helperService.getPasswordTemplate(body.full_name, password),
      });
      const { password: _, ...result } = employee;

      return result;

    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === "P2003") {
          // Foreign key constraint failed
          throw new BadRequestException("Invalid foreign key reference");
        }
        // Unique constraint violation
      } else if (error instanceof Prisma.PrismaClientValidationError) {
        throw new BadRequestException("Invalid data provided");
      }
      // Fallback for unexpected errors
      throw new InternalServerErrorException("Failed to create employee");
    }
  }

  async getAllEmployees(language: string, user: any, pagination: { page: number, limit: number, skip: number }, filter: string) {
    const employees = await this.prisma.employees.findMany({ 
      where: { full_name: { contains: filter, mode: 'insensitive' },
      ...(user.role_name !== superAdminEnums.ROLE_EN_NAME
        ? { roles: { is: { company_project_id: +user.company_project_id } } }
        : {})
     },
      skip: pagination.skip,
      take: pagination.limit,
      include: { roles: { select: { [`${language}_name`]: true, id: true, company_project_id: true, 
      company_project: { select: { company_code: true, project_code: true, [`${language}_name`]: true } } 
      } } } });

      const totalCount = await this.prisma.employees.count({
        where: { full_name: { contains: filter, mode: 'insensitive' },
        ...(user.role_name !== superAdminEnums.ROLE_EN_NAME 
          ? { roles: { is: { company_project_id: +user.company_project_id } } }
          : {})
       }
      });

    const formattedEmployees = employees.map((employee) => {
      const { password, ...emp } = employee;
      const roleName = employee.roles ? employee.roles[`${language}_name`] : null;
      const projectName = employee.roles?.company_project
        ? employee.roles.company_project[`${language}_name`]
        : null;

        const roles = employee.roles ? { ...employee.roles } : null;
        if (roles) {
          delete roles[`${language}_name`];
          if (roles.company_project) {
            delete roles.company_project[`${language}_name`];
          }
        }

      return {
        ...emp,
        roles,
        role_name: roleName,
        project_name: projectName
      };
    });

    return {
      totalCount,
      totalPages: Math.ceil(totalCount / pagination.limit),
      employees: formattedEmployees,

    };
  }
}
